<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Given when then</title>
    <link href="./css/opensans-fonts.css"                          type="text/css" rel="stylesheet" />
    <link href="./css/bootstrap.min.css"                           type="text/css" rel="stylesheet" />
    <link href="./css/font-awesome.min.css"                        type="text/css" rel="stylesheet" />
    <link href="./css/prettify.css"                                type="text/css" rel="stylesheet" />
    <link href="./css/tabber.css"                                  type="text/css" rel="stylesheet" />
    <link href="./css/tipuesearch.css"                             type="text/css" rel="stylesheet" />
    <link href="./css/specs2.css"                                  type="text/css" rel="stylesheet" />
    <link href="./css/specs2-user.css"                             type="text/css" rel="stylesheet" />

    <script src="./javascript/jquery.js"                           type="text/javascript"></script>
    <script src="./javascript/jquery.jstree.js"                    type="text/javascript"></script>
    <script src="./javascript/tabber.js"                           type="text/javascript"></script>
    <script src="./javascript/tabber_start.js"                     type="text/javascript"></script>
    <script src="./javascript/prettify.js"                         type="text/javascript"></script>
    <script src="./javascript/specs2.js"                           type="text/javascript"></script>
    <script src="./javascript/specs2-user.js"                      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_set.js"      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_contents.js" type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch.min.js"      type="text/javascript"></script>

</head>
<body onload="prettyPrint()">

<div class="container">

<div class="col-md-2 sidebar-outer">
<div class="col-md-2 fixed">

<!-- search box -->
<div class="search-box">
  <form action="search.html">
    <input type="text" name="q" id="tipue_search_input" autocomplete="off" required>
  </form>
</div>

<!-- table of contents -->
<div id="tree"><ul>
                <li id="org-specs2-guide-consoleoutput"><a href="org.specs2.guide.ConsoleOutput.html" title="Console output">Console output</a>
      <ul><ul><li><a href="org.specs2.guide.ConsoleOutput.html#show-only" title="Show only">Show only</a>
          
        </li><li><a href="org.specs2.guide.ConsoleOutput.html#stacktracefilter" title="StackTraceFilter">StackTraceFilter</a>
          
        </li><li><a href="org.specs2.guide.ConsoleOutput.html#diffs" title="Diffs">Diffs</a>
          
        </li><li><a href="org.specs2.guide.ConsoleOutput.html#colors" title="Colors">Colors</a>
          
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul></div><script>$(function () { $('#tree').jstree({'core':{'initially_open':['org-specs2-guide-givenwhenthenstyle'], 'animation':200}, 'themes' : {'theme': 'default','url': './css/themes/default/style.css'}, 'plugins':['themes', 'html_data']}); });</script>

</div>
</div>


<div class="col-md-10">
<h1>Given when then</h1>
<div id="tipue_search_content"></div>

<h2 id="presentation">Presentation</h2>
<p>The Given/When/Then style structures the specification with 3 main elements:</p>
<ul>
<li>Given steps: actions which setup the system</li>
<li>When steps: command which your are currently specifying</li>
<li>Then steps: expectations about the end state of the system</li>
</ul>
<p>In <s2>specs2</s2> the support for Given/When/Then can be more or less complex depending on the features you wish to use:</p>
<ul>
<li>basic support: given and when steps are just commands on a system, returning no value</li>
<li>intermediate support: given/when/then steps can parse part of the text to create their commands</li>
<li>full support: variables are not necessary to save intermediate values and the given/when/then order is enforced</li>
</ul>
<h2 id="basic-support">Basic support</h2>
<h3 id="with-an-acceptance-specification">With an acceptance specification</h3>
<p>Given/When/Then specifications are easy to write using the acceptance style, you just use regular text, steps and examples:</p>
<pre><code class="prettyprint">class GWTSpec extends Specification { def is = s2&quot;&quot;&quot;
 Given a first number         $g1
 When I double it             $w1
 Then I get twice that number $t1
&quot;&quot;&quot;
  var number = 0
  def g1 = step {
    // do something to provide a number
    number = 1
  }

  def w1 = step {
    // do an action
    number *= number
  }
  // check the result
  def t1 = number must_== 2
}</code></pre>
<h3 id="with-a-mutable-specification">With a mutable specification</h3>
<p>With a mutable specification you would write:</p>
<pre><code class="prettyprint">class GWTSpec extends mutable.Specification {

 &quot;Given a first number&quot;.txt.p
  step { number = 1 }

  &quot;When I double it&quot;.br
  step { number *= number }

  &quot;Then I get twice that number&quot; &gt;&gt; {
    number must_== 2
  }

  var number = 0
}</code></pre>
<h2 id="intermediate-support">Intermediate support</h2>
<p>Given/When/Then specifications are often written as blocks of text where part of the text contains values to use during the execution. For example:</p>
<pre><code class="prettyprint">This is a specification for a bank transfer

 given an account with the amount {100}
 given another account with the amount {500}
 when we transfer {50} from the first account to the second
 then the first amount is {50} and the second is {550}</code></pre>
<p>How do you code this with an acceptance specification?</p>
<h3 id="with-an-acceptance-specification-1">With an acceptance specification</h3>
<p>You can implement this approach with the <code class="prettyprint">org.specs2.specification.dsl.GWT</code> trait:</p>
<pre><code class="prettyprint">class GWTSpec extends Specification with specification.dsl.GWT with StandardDelimitedStepParsers { def is = s2&quot;&quot;&quot;
 Given a first number {2}     $g1
 When multiply it by {3}      $w1
 Then I get {6}               $t1
&quot;&quot;&quot;
  var number = 0
  def g1 = step(anInt) { i =&gt; number = i }

  def w1 = step(anInt) { j =&gt; number = number * j }

  def t1 = example(anInt) { n =&gt; number must_== n }
}</code></pre>
<p>Now we need a bit of help to extract values from the text. This is provided in the form of <code class="prettyprint">StepParsers</code>.</p>
<h4 id="delimited-parsers">Delimited parsers</h4>
<p>The easiest way to extract values from a string is to delimit exactly where are the values to extract, then to provide a way to give them meaningful types. This is the role of <code class="prettyprint">StepParsers</code>. Those parsers are using <code class="prettyprint">{}</code> as delimiters for the values you want to extract. For example you can define an extractor for Int values like this:</p>
<pre><code class="prettyprint">val anInt = StepParser((_: String).toInt)</code></pre>
<p>The <code class="prettyprint">anInt</code> step parser has a method <code class="prettyprint">parse(text: String)</code> returning:</p>
<ul>
<li>either an exception if the parse is unsuccessful</li>
<li>or the desired value + the original text stripped for its delimiters</li>
</ul>
<p>You can change the delimiters being used by overriding the implicit regular expression from the <code class="prettyprint">StepParsers</code> trait:</p>
<pre><code class="prettyprint">  // use `[]` as a delimiter
  override implicit lazy val stepParserRegex = new Regex(&quot;\\[([^\\]]+)\\]&quot;)</code></pre>
<p>But you can also specify another regular expression “locally” for a given step parser:</p>
<pre><code class="prettyprint">val anInt = StepParser((_: String).toInt)(new Regex(&quot;\\[([^\\]]+)\\]&quot;))</code></pre>
<p>Finally <code class="prettyprint">StepParsers</code> can collect all the delimited values at once with the <code class="prettyprint">seq</code> method:</p>
<pre><code class="prettyprint">StepParser.seq((seq: Seq[String]) =&gt; seq.map(_.toInt).sum).parse(&quot;values {1}, {2}, {3}&quot;) === Right(6)</code></pre>
<h4 id="regex-parsers">Regex parsers</h4>
<p>More generally you can use any regular expression to parse values with the <code class="prettyprint">readAs</code> and <code class="prettyprint">groupAs</code> methods</p>
<pre><code class="prettyprint">// match the whole line
val anInt1 = readAs(&quot;.*(\\d+).*&quot;).and((s: String) =&gt; s.toInt)

// just declare the groups you want to match
val anInt2 = groupAs(&quot;\\d+&quot;).and((s: String) =&gt; s.toInt)

// note: if you want to extract 2 ints, just pass a function of 2 arguments
val twoInts = groupAs(&quot;\\d+&quot;).and((s1: String, s2: String) =&gt; (s1.toInt, s2.toInt))</code></pre>
<h4 id="standard-parsers">Standard parsers</h4>
<p>A few <code class="prettyprint">StepParsers</code> have been predefined for you in the <code class="prettyprint">StandardDelimitedStepParsers</code> and <code class="prettyprint">StandardRegexStepParsers</code> traits to extract <code class="prettyprint">Int</code>s, <code class="prettyprint">Double</code>s and <code class="prettyprint">String</code>s:</p>
<ul>
<li><code class="prettyprint">anInt</code>, <code class="prettyprint">twoInts</code>, <code class="prettyprint">threeInts</code></li>
<li><code class="prettyprint">aDouble</code>, <code class="prettyprint">twoDoubles</code>, <code class="prettyprint">threeDoubles</code></li>
<li><code class="prettyprint">aString</code>, <code class="prettyprint">twoStrings</code>, <code class="prettyprint">threeStrings</code></li>
</ul>
<h3 id="with-a-mutable-specification-1">With a mutable specification</h3>
<p>Several syntaxes are available with a mutable specification. The first syntax uses modified <code class="prettyprint">step</code> and <code class="prettyprint">example</code> methods to create steps and examples:</p>
<pre><code class="prettyprint">class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT with StandardDelimitedStepParsers {

  &quot;adding numbers&quot;.p

  step(&quot;Given a first number {2}&quot;)(anInt) { i =&gt;
    number = i
  }

  step(&quot;When I multiply it by {3}&quot;)(anInt) { j =&gt;
    number = number * j
  }

  example(&quot;Then I get {6}&quot;)(anInt) { n: Int =&gt;
    number must_== n
  }

  var number = 0
}</code></pre>
<p>The second syntax is mostly the same but with postfix methods:</p>
<pre><code class="prettyprint">class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT with StandardDelimitedStepParsers {

  &quot;adding numbers&quot;.p

  &quot;Given a first number {2}&quot;.step(anInt) { i =&gt;
    number = i
  }

  &quot;When I multiply it by {3}&quot;.step(anInt) { j =&gt;
    number = number * j
  }

  &quot;Then I get {6}&quot;.example(anInt) { n: Int =&gt;
    number must_== n
  }

  var number = 0
}</code></pre>
<p>Those two syntaxes are just specialisations of the <code class="prettyprint">mutable.GivenWhenThen</code> trait which provides <code class="prettyprint">Given/When/Then</code> keywords:</p>
<pre><code class="prettyprint">class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT with StandardDelimitedStepParsers with GivenWhenThenSyntax {

  &quot;adding numbers&quot;.p

  Given(&quot;a first number {2}&quot;)(anInt) { i =&gt;
    number = i
  }

  When(&quot;I multiply it by {3}&quot;)(anInt) { j =&gt;
    number = number * j
  }

  Then(&quot;I get {6}&quot;)(anInt) { n: Int =&gt;
    number must_== n
  }

  var number = 0
}</code></pre>
<p>This will create sentences such as:</p>
<pre><code class="prettyprint">Given a first number 2
When I multiply it by 3
Then I get 6</code></pre>
<p>If you prefer to have uncapitalized <code class="prettyprint">given/when/then</code> methods you can use the <code class="prettyprint">GivenWhenAndThenSyntax</code> trait:</p>
<pre><code class="prettyprint">class GWTSpec extends mutable.Specification with org.specs2.specification.dsl.mutable.GWT
  with StandardDelimitedStepParsers with GivenWhenAndThenSyntax {

  &quot;adding numbers&quot;.p

  given(&quot;a first number {2}&quot;)(anInt) { i =&gt;
    number = i
  }

  when(&quot;I multiply it by {3}&quot;)(anInt) { j =&gt;
    number = number * j
  }

  andThen(&quot;I get {6}&quot;)(anInt) { n: Int =&gt;
    number must_== n
  }

  var number = 0
}</code></pre>
<p>Which renders</p>
<pre><code class="prettyprint">given a first number 2
when I multiply it by 3
then I get 6</code></pre>
<p>In this case <code class="prettyprint">andThen</code> has to be used in place of <code class="prettyprint">then</code> because <code class="prettyprint">then</code> is going to become a Scala keyword in future releases.</p>
<h2 id="full-support">Full support</h2>
<p>The full support fixes an issue with all the previous styles: the necessity to create mutable variables to keep track of state changes between steps and examples. It also enforces statically a proper sequencing of the Given/When/Then actions.</p>
<p>Here, we mix-in the <code class="prettyprint">org.specs2.specification.script.GWT</code> trait. This trait provides a class, <code class="prettyprint">Scenario</code>, to parse the specification text and create <code class="prettyprint">Steps</code> and <code class="prettyprint">Examples</code>. Let’s see an example:</p>
<pre><code class="prettyprint">class GWTSpec extends Specification with org.specs2.specification.script.GWT with StandardRegexStepParsers { def is = s2&quot;&quot;&quot;

 A given-when-then example for a calculator                       ${calculator1.start}
   Given the following number: 1
   And a second number: 2
   And a third number: 6
   When I use this operator: +
   Then I should get: 9
   And it should be &gt;: 0                                          ${calculator1.end}

&quot;&quot;&quot;

  val anOperator = readAs(&quot;.*: (.)$&quot;).and((s: String) =&gt; s)

  val calculator1 =
    Scenario(&quot;calculator1&quot;).
      given(anInt).
      given(anInt).
      given(anInt).
      when(anOperator) { case op :: i :: j :: k :: _ =&gt; if (op == &quot;+&quot;) i + j + k else i * j * k }.
      andThen(anInt)   { case expected :: sum :: _ =&gt; sum === expected}.
      andThen(anInt)   { case expected :: sum :: _ =&gt; sum must be_&gt;(expected)}
}</code></pre>
<p>In this example, <code class="prettyprint">calculator1.start</code> marks the beginning of a Given/When/Then section and each line until <code class="prettyprint">calculator1.end</code> must correspond to a <code class="prettyprint">given</code>, <code class="prettyprint">when</code> or <code class="prettyprint">andThen</code> call on the scenario.</p>
<ul>
<li><code class="prettyprint">given</code> uses a <code class="prettyprint">StepParser</code> to extract values for a line of text</li>
<li><code class="prettyprint">when</code> uses a <code class="prettyprint">StepParser</code> to extract values from the corresponding line of text and a <code class="prettyprint">mapping</code> function to combine the result of the extraction + all the values from the given steps</li>
<li><code class="prettyprint">andThen</code> uses a <code class="prettyprint">StepParser</code> (usually to extract expected values) and a <code class="prettyprint">check</code> function taking <code class="prettyprint">when values</code> and returning a <code class="prettyprint">Result</code></li>
</ul>
<p>More precisely, the functions passed to a <code class="prettyprint">when</code> step must be of the form</p>
<ul>
<li><code class="prettyprint">when(aStepParser) { case p1 :: p2 :: .. :: _ =&gt; w1 }</code>, where <code class="prettyprint">p1</code> has the type extracted from <code class="prettyprint">aStepParser</code> and <code class="prettyprint">p2 .. pn</code> have the types of the values extracted by the previous <code class="prettyprint">given</code> steps</li>
<li><code class="prettyprint">when(aStepParser).collect { case (p1, p2n: Seq[LUB]) =&gt; w1 }</code>, where <code class="prettyprint">p1</code> has the type extracted from <code class="prettyprint">aStepParser</code> and <code class="prettyprint">p2n</code> is a <code class="prettyprint">Seq[LUB]</code> where <code class="prettyprint">LUB</code> is the least upper bound of the types of all the values extracted by the previous <code class="prettyprint">given</code> steps</li>
</ul>
<p><code class="prettyprint">::</code> is the <a href="https://github.com/milessabin/shapeless">Shapeless</a> <code class="prettyprint">HCons</code> operator so don’t forget to add the Shapeless dependency to your project if you are using the <code class="prettyprint">GWT</code> trait!</p>
<p>And similarly for <code class="prettyprint">andThen</code> steps</p>
<ul>
<li><code class="prettyprint">andThen(aStepParser) { case p1 :: p2 :: .. :: _ =&gt; r: R }</code>, where <code class="prettyprint">p1</code> has the type extracted from <code class="prettyprint">aStepParser</code> and <code class="prettyprint">p2 .. pn</code> have the types of the values mapped by the previous <code class="prettyprint">when</code> steps</li>
<li><code class="prettyprint">andThen(aStepParser).collect { case (p1, p2n: Seq[LUB]) =&gt; r: R }</code>, where <code class="prettyprint">p1</code> has the type extracted from <code class="prettyprint">aStepParser</code> and <code class="prettyprint">p2n</code> is a <code class="prettyprint">Seq[LUB]</code> where <code class="prettyprint">LUB</code> is the least upper bound of the types of all the values mapped by the previous <code class="prettyprint">when</code> steps</li>
</ul>
<p>The type <code class="prettyprint">R</code> of the value <code class="prettyprint">r</code> must be such that there is an <code class="prettyprint">AsResult</code> type class instance in scope to transform it to a <code class="prettyprint">Result</code>. In other words r is: a <code class="prettyprint">Boolean</code>, a <code class="prettyprint">MatchResult[_]</code>, a ScalaCheck <code class="prettyprint">Prop</code>,…</p>
<p>You will also note that the <code class="prettyprint">Scenario</code> class restricts the order of methods which you can call. It always has to be <code class="prettyprint">given* -&gt; when* -&gt; andThen*</code>.</p>
<h3 id="and-if-you-want-to-know-more" class="ribbon both-ribbon">And if you want to know more</h3>
<div class="ribbon-content">
<ul>
<li>read about the <link class="ok"> <a href="org.specs2.guide.RunInShell.html" tooltip="" class="ok">dependencies for the GWT trait</a></link></li>
</ul>
</div>
</div>

<script>
$(document).ready(function() {
  $('#tipue_search_input').tipuesearch({
    'show': 6
  });
});
</script>
</div>

</body>
</html>