<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Mockito</title>
    <link href="./css/opensans-fonts.css"                          type="text/css" rel="stylesheet" />
    <link href="./css/bootstrap.min.css"                           type="text/css" rel="stylesheet" />
    <link href="./css/font-awesome.min.css"                        type="text/css" rel="stylesheet" />
    <link href="./css/prettify.css"                                type="text/css" rel="stylesheet" />
    <link href="./css/tabber.css"                                  type="text/css" rel="stylesheet" />
    <link href="./css/tipuesearch.css"                             type="text/css" rel="stylesheet" />
    <link href="./css/specs2.css"                                  type="text/css" rel="stylesheet" />
    <link href="./css/specs2-user.css"                             type="text/css" rel="stylesheet" />

    <script src="./javascript/jquery.js"                           type="text/javascript"></script>
    <script src="./javascript/jquery.jstree.js"                    type="text/javascript"></script>
    <script src="./javascript/tabber.js"                           type="text/javascript"></script>
    <script src="./javascript/tabber_start.js"                     type="text/javascript"></script>
    <script src="./javascript/prettify.js"                         type="text/javascript"></script>
    <script src="./javascript/specs2.js"                           type="text/javascript"></script>
    <script src="./javascript/specs2-user.js"                      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_set.js"      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_contents.js" type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch.min.js"      type="text/javascript"></script>

</head>
<body onload="prettyPrint()">

<div class="container">

<div class="col-md-2 sidebar-outer">
<div class="col-md-2 fixed">

<!-- search box -->
<div class="search-box">
  <form action="search.html">
    <input type="text" name="q" id="tipue_search_input" autocomplete="off" required>
  </form>
</div>

<!-- table of contents -->
<toc/>

</div>
</div>


<div class="col-md-10">
<h1>Mockito</h1>
<div id="tipue_search_content"></div>

<p><a href="https://code.google.com/p/mockito">Mockito</a> allows to specify stubbed values and to verify that some calls have been made to your objects. In order to use those features, you need to extend the <code class="prettyprint">org.specs2.mock.Mockito</code> trait:</p>
<pre class="prettyprint"><code class="prettyprint">class MockitoSpec extends Specification with Mockito { def is = s2&quot;&quot;&quot;

A java list can be mocked
  You can make it return a stubbed value        ${c().stub}
  You can verify that a method was called       ${c().verify}
  You can verify that a method was not called   ${c().verify2}

&quot;&quot;&quot;

  case class c() {
    val m = mock[java.util.List[String]] // a concrete class would be mocked with: mock[new java.util.LinkedList[String]]
    def stub = {
      m.get(0) returns &quot;one&quot;             // stub a method call with a return value
      m.get(0) must_== &quot;one&quot;             // call the method
    }
    def verify = {
      m.get(0) returns &quot;one&quot;             // stub a method call with a return value
      m.get(0)                           // call the method
      there was one(m).get(0)            // verify that the call happened
    }
    def verify2 = there was no(m).get(0) // verify that the call never happened
  }
}</code></pre>
<h3 id="creation-and-settings">Creation and settings</h3>
<p>Mockito offers the possibility to provide specific settings for the mock being created:</p>
<ul>
<li>a name</li>
</ul>
<p><code class="prettyprint">val m = mock[List[String]].as(&quot;list1&quot;)</code></p>
<ul>
<li><a href="https://code.google.com/p/specs/wiki/UsingMockito#Smart_mocks">“smart” return values</a></li>
</ul>
<p><code class="prettyprint">val m = mock[List[String]].smart</code></p>
<ul>
<li><code class="prettyprint">verbose</code> to enable Mockito’s verbose logging</li>
</ul>
<p><code class="prettyprint">val m = mock[List[String]].verbose</code></p>
<ul>
<li>specific return values</li>
</ul>
<p><code class="prettyprint">val m = mock[List[String]].defaultReturn(10)</code></p>
<ul>
<li>specific answers</li>
</ul>
<pre class="prettyprint"><code class="prettyprint">// a function InvocationOnMock =&gt; V is used in place of the org.mockito.stubbing.Answer type for better conciseness
val helloObject = (p1: InvocationOnMock) =&gt; &quot;hello &quot;+p1.toString
val m = mock[List[String]].defaultAnswer(helloObject)</code></pre>
<ul>
<li>extra interfaces</li>
</ul>
<pre class="prettyprint"><code class="prettyprint">val m1 = mock[List[String]].extraInterface[Cloneable]
val m2 = mock[List[String]].extraInterfaces[Cloneable, Serializable]</code></pre>
<p>Now, if you want to combine several of those settings together you need to call the <code class="prettyprint">settings</code> method:</p>
<pre class="prettyprint"><code class="prettyprint">val m1 = mock[List[String]].settings(name = &quot;list1&quot;,
  defaultReturn = 10,
  extraInterfaces = classesOf[Cloneable, Serializable])
// or
val m2 = mock[List[String]].settings(smart = true,
  extraInterface = classOf[Cloneable])</code></pre>
<p>Finally, you can pass a <code class="prettyprint">org.mockito.MockSettings</code> object directly to the <code class="prettyprint">mock</code> method:</p>
<pre class="prettyprint"><code class="prettyprint">val settings = org.mockito.Mockito.withSettings
val m = mock[List[String]](settings)</code></pre>
<h3 id="stubbing">Stubbing</h3>
<p>Stubbing values is as simple as calling a method on the mock and declaring what should be returned or thrown:</p>
<pre class="prettyprint"><code class="prettyprint">m.get(1) returns &quot;one&quot;
m.get(2) throws new RuntimeException(&quot;forbidden&quot;)</code></pre>
<p>You can specify different consecutive returned values by appending <code class="prettyprint">thenReturns</code> or <code class="prettyprint">thenThrows</code>:</p>
<pre class="prettyprint"><code class="prettyprint">m.get(1) returns &quot;one&quot; thenReturns &quot;two&quot;
m.get(2) throws new RuntimeException(&quot;forbidden&quot;) thenReturns &quot;999&quot;</code></pre>
<h3 id="mocking-and-stubbing-at-the-same-time">Mocking and Stubbing at the same time</h3>
<p>It is also possible to create a mock while stubbing one of its methods, provided that you declare the type of the expected mock:</p>
<pre class="prettyprint"><code class="prettyprint">val mocked: java.util.List[String] = mock[java.util.List[String]].contains(&quot;o&quot;) returns true
mocked.contains(&quot;o&quot;) must beTrue</code></pre>
<h3 id="with-matchers">With matchers</h3>
<p>The built-in Mockito argument matchers can be used to specify the method arguments for stubbing:</p>
<pre class="prettyprint"><code class="prettyprint">m.get(org.mockito.Matchers.anyInt()) returns &quot;element&quot;
m.get(999) must_== &quot;element&quot;</code></pre>
<p><s2>specs2</s2> matchers can also be passed directly as arguments:</p>
<pre class="prettyprint"><code class="prettyprint">m.get(===(123)) returns &quot;one&quot;</code></pre>
<p><em>Note</em>: the call above works because there is an implicit method <code class="prettyprint">argThat</code> which transforms a <s2>specs2</s2> <code class="prettyprint">Matcher[T]</code> into a Hamcrest one and in turn call Mockito’s <code class="prettyprint">org.mockito.Matchers.argThat</code> method to register the Hamcrest matcher. However <a href="https://groups.google.com/forum/#!msg/specs2-users/_slOZQoICzU/DF-ZQCq_GmkJ">sometimes</a> the implicit conversion is not called and you have to explicitly call the <code class="prettyprint">argThat</code> method like so:</p>
<pre class="prettyprint"><code class="prettyprint">m.get(argThat(===(123))) returns &quot;one&quot;</code></pre>
<h3 id="callbacks">Callbacks</h3>
<p>In some rare cases, it is necessary to have the return value depend on the parameters passed to the mocked method:</p>
<pre class="prettyprint"><code class="prettyprint">m.get(anyInt) answers { i =&gt; &quot;The parameter is &quot; + i.toString }</code></pre>
<p>The function passed to <code class="prettyprint">answers</code> will be called with each parameter passed to the stubbed method:</p>
<pre class="prettyprint"><code class="prettyprint">m.get(0)    // returns &quot;The parameter is 0&quot;
m.get(1)    // the second call returns a different value: &quot;The parameter is 1&quot;</code></pre>
<h4 id="parameters-for-the-answers-function">Parameters for the <code class="prettyprint">answers</code> function</h4>
<p>Because of the use of reflection the function passed to answers will receive only instances of the <code class="prettyprint">java.lang.Object</code> type.</p>
<p>More precisely, it will:</p>
<ul>
<li>pass the mock object if both the method has no parameters and the function has one parameter: <code class="prettyprint">mock.size answers { mock =&gt; mock.hashCode }</code></li>
<li>pass the parameter if both the method and the function have one parameter: <code class="prettyprint">mock.get(0) answers { i =&gt; i.toString }</code></li>
<li>pass the parameter and the mock object if the method has 1 parameter and the function has 2: <code class="prettyprint">mock.get(0) answers { (i, mock) =&gt; i.toString + &quot; for mock &quot; + mock.toString }</code></li>
</ul>
<p>In any other cases, if <code class="prettyprint">f</code> is a function of 1 parameter, the array of the method parameters will be passed and if the function has 2 parameters, the second one will be the mock.</p>
<h3 id="verification">Verification</h3>
<p>By default Mockito doesn’t expect any method to be called. However if you are writing interaction-based specifications you want to specify that some methods are indeed called:</p>
<pre class="prettyprint"><code class="prettyprint">there was one(m).get(0)              // one call only to get(0)
there was no(m).get(0)               // no calls to get(0)

// were can also be used
there were two(m).get(0)             // 2 calls exactly to get(0)
there were three(m).get(0)           // 3 calls exactly to get(0)
there were 4.times(m).get(0)         // 4 calls exactly to get(0)

there was atLeastOne(m).get(0)       // at least one call to get(0)
there was atLeastTwo(m).get(0)       // at least two calls to get(0)
there was atLeastThree(m).get(0)     // at least three calls to get(0)
there was atLeast(4)(m).get(0)       // at least four calls to get(0)

there was atMostOne(m).get(0)        // at most one call to get(0)
there was atMostTwo(m).get(0)        // at most two calls to get(0)
there was atMostThree(m).get(0)      // at most three calls to get(0)
there was atMost(4)(m).get(0)        // at most four calls to get(0)

// the combinators above, except `atMost`, can also be used with a timeout
there was after(10.millis).one(m).get(0)
there was after(2.seconds).two(m).get(0)</code></pre>
<p>It is also possible to add all verifications inside a block, when several mocks are involved:</p>
<pre class="prettyprint"><code class="prettyprint">got {
  one(m).get(0)
  two(m).get(1)
}</code></pre>
<h4 id="order-of-calls">Order of calls</h4>
<p>The order of method calls can be checked by creating calls and chaining them with <code class="prettyprint">andThen</code>:</p>
<pre class="prettyprint"><code class="prettyprint">val m1 = mock[java.util.List[String]]

m1.get(0)
m1.get(1)

there was one(m1).get(0) andThen one(m1).get(1)</code></pre>
<p>when several mocks are involved, the expected order must be specified as an implicit value:</p>
<pre class="prettyprint"><code class="prettyprint">val m1 = mock[java.util.List[String]]
val m2 = mock[java.util.List[String]]
val m3 = mock[java.util.List[String]]

// the order of mock objects doesn&#39;t matter here
implicit val order = inOrder(m1, m3, m2)

m1.get(1); m2.get(2); m3.get(3)

there was one(m1).get(1) andThen one(m2).get(2) andThen one(m3).get(3)</code></pre>
<h4 id="ignoring-stubs">Ignoring stubs</h4>
<p>When specifying the behavior of an object in relation to others you may want to verify that some mocks have been called as collaborators and you don’t really want to specify what happens to other mocks because they are just playing the role of stubs.</p>
<p>In this case the <code class="prettyprint">ignoreStubs</code> method can be used:</p>
<pre class="prettyprint"><code class="prettyprint">val (stub1, stub2) = (mock[AStub], mock[AStub])
there were noMoreCallsTo(ignoreStubs(stub1, stub2))</code></pre>
<p>This method is also available with the <code class="prettyprint">inOrder</code> method:</p>
<pre class="prettyprint"><code class="prettyprint">implicit val order = inOrder(ignoreStubs(list1, list2))</code></pre>
<p>For more documentation about this Mockito functionality, please read <a href="http://docs.mockito.googlecode.com/hg/1.9.0/org/mockito/Mockito.html#25">here</a>.</p>
<h4 id="spies">Spies</h4>
<p>Spies can be used to do “partial mocking” of real objects:</p>
<pre class="prettyprint"><code class="prettyprint">val spiedList = spy(new LinkedList[String])

// methods can be stubbed on a spy
spiedList.size returns 100

// other methods can also be used
spiedList.add(&quot;one&quot;)
spiedList.add(&quot;two&quot;)

// and verification can happen on a spy
there was one(spiedList).add(&quot;one&quot;)</code></pre>
<p>However, working with spies can be tricky:</p>
<pre class="prettyprint"><code class="prettyprint">// if the list is empty, this will throws an IndexOutOfBoundsException
spiedList.get(0) returns &quot;one&quot;</code></pre>
<p>As advised in the Mockito documentation, <code class="prettyprint">doReturn</code> must be used in that case:</p>
<pre class="prettyprint"><code class="prettyprint">org.mockito.Mockito.doReturn(&quot;one&quot;).when(spiedList).get(0)</code></pre>
<h4 id="functions-partialfunctions">Functions / PartialFunctions</h4>
<p>It is possible to verify method calls where parameters are functions by specifying how the passed function will react to a given set of arguments. Given the following mock:</p>
<pre class="prettyprint"><code class="prettyprint">trait Amount {
  // a method showing an amount precision
  def show(display: (Double, Int) =&gt; String) = ???
}

val amount = mock[Amount]</code></pre>
<p>If the mock is called with this function:</p>
<pre class="prettyprint"><code class="prettyprint">amount.show((amount: Double, precision: Int) =&gt; &quot;%2.&quot;+precision+&quot;f&quot; format amount)</code></pre>
<p>Then it is possible to verify how the mock was called:</p>
<pre class="prettyprint"><code class="prettyprint">// with sample arguments for the function and the expected result
there was one(amount).show((32.4456, 2) -&gt; &quot;32.45&quot;)

// with a matcher for the result
there was one(amount).show((32.4456, 2) -&gt; endWith(&quot;45&quot;))

// with any Function2[A, B, R]
there was one(amount).show(anyFunction2)</code></pre>
<h4 id="auto-boxing">Auto-boxing</h4>
<p>Auto-boxing might interfere with the mocking of PartialFunctions. Please have a look at <a href="https://groups.google.com/d/topic/specs2-users/_bK8lCCjZ4c/discussion">this</a> for a discussion.</p>
<h4 id="byname">Byname</h4>
<p>Byname parameters can be verified but this will not work if the <s2>specs2</s2> jar is not put first on the classpath, before the mockito jar. Indeed <s2>specs2</s2> redefines a Mockito class for intercepting method calls so that byname parameters are properly handled.</p>
</div>

<script>
$(document).ready(function() {
  $('#tipue_search_input').tipuesearch({
    'show': 6
  });
});
</script>
</div>

</body>
</html>